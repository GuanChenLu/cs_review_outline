# 虚拟存储器

是这种结构吗？

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220413172926.png)



## 出现的原因

程序所需要的存储器的容量(主存容量)和计算机配备的容量存在矛盾

- 需要大容量的程序要在小容量的主存上运行
- 在多任务系统中，多个任务 **共享内存**，在编程时无法确定某个程序到底占用的是实际内存中的那一部分

针对上面的两点，我们提出设计虚拟存储需要满足的要求

1. 不需要考虑程序是否在主存中装得下
2. 不用考虑物理地址，在编程时分配地址空间给程序如果超出实际物理内存中的剩余，会只调入正在进行和即将要经行的块，其余的驻留在主存之外(下面称之为辅助存储，简称辅存)

这样一来，我们可以说，**我们面向虚存编程，虚存的空间大小仅仅限制于辅存的大小**



## 虚存的访问过程

与从 CPU 引脚引出的实地址相对的，是在程序中给出的对应的逻辑地址，也就是编程时我们所用到的地址，我们称虚地址到实地址的转换为 `再定位`



虚拟空间的用户程序按照 `虚地址编程` 并且放在主存外

在每次与存储地址打交道的时候，首先应该判断给出的虚地址经过再定位之后对应的部分是否在主存中，如果是，经过地址转换之后直接访问，如果不是，将对应部分调入内存中，然后访问

如果虚拟地址通过内存地址转换之后没有命中主存，会触发 `缺页中断`，由操作系统从主存之外将页调入

所以说，系统设计者在设计虚存时需要解决下面的问题

1. 调度问题，决定哪些部分应该被调入主存
2. 地址映射，在访问主存时将其变换为主存物理地址(内地址变换)、在访问主存外经行外地址变换
3. 替换问题
4. 更新

下面介绍三种存储器的地址映射机制

### 页式映射

虚地址空间和储存空间都被分为等长的页，发被称为逻辑页和存储页

虚存和实存地址的划分如下

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414193519.png)

虚拟地址可以通过逻辑页号找到物理页号，然后通过加上页内行地址找到对应的实存地址

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414193745.png)



优点：

1. 页长固定，方便构造页表
2. 以整页为单位进行操作，不存在外碎片

缺点：

1. 页长与程序的逻辑大小无关，不利于程序的独立性
2. 换入换出，存储保护、存储共享比较麻烦



为了提高效率，我们可以将页表中访问最活跃的部分放在由高速存储器实现的 `快表中(TLB, translation lookaside buffer)`中，**注意，这里的 TLB 在三种映射方式中都是可以发挥作用的**

`TLB` 配合页表和 `cache`，构成了三层层次关系

```shell
TLB -> 页表(能够转换成主存中的物理地址) -> cache(对主存中的部分地址进行缓存)
```



1. 最好的情况下，可以直接从 `TLB` 中找到对应的物理页号(直接通过 `cache` 转换，然后从 `cache` 中取出数据并返回)
2. 最坏的情况下，三层都缺失，触发缺页中断，从主存之外加载数据向上缓存到这三层



### 段式映射

划分主存为多个大小的段，通过主存中的段表中的段号和段表确定

虚拟地址变成实际主存地址，就需要通过 `段表`

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414200440.png)

可以理解为，段式存储就是按照程序划分出的内存空间大小的页式存储

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414201035.png)

它的优点很显然

1. 段与段在逻辑上是独立的，便于管理和修改，多道程序共享
2. 段长可变，有利于有效利用主存空间

缺点也很明显

1. 主存空间分配比较麻烦，容易产生内存碎片
2. 由于无法规定像页式管理那样产生 `2^n` 的段长，所以无法规定像虚地址和实地址的最低若干二进制位作为段内偏移量直接和段号拼接得到地址，而必须通过加法运算得到地址，因此需要更多的硬件支持



### 段页式映射

主存被分成页

每个程序先按照逻辑结构(数据段、代码段、堆、栈段)分段，然后在每段中按照实存的页大小分页

这样的话，程序可以做到按照页执行调入调出操作，也可以按照段进行编程、保护和共享

唯一的缺点应该就是需要多次查表，但是引入 `TLB` 会提高效率

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414202600.png)



1. 基址寄存器通过基号找到段表
2. 根据 1号 段表找出属于程序的段，取出段地址作为后面的页表的起始地址
3. 通过 2号页号 检索页表，得到物理页号
4. 物理页号与页内地址拼接直接得到物理地址



## 虚存的替换算法

虚存的替换有操作系统的支持

虚存缺页比 `cache未命中`对性能的影响大很多

虚存决心替换的选择余地较大，一个进程的页面都可以替换



虚拟存储器中的替换策略一般采用近期最少使用(LRU)算法、最不经常使用(LFU)算法、先进先出(FIFO)算法，或将两种算法结合起来使用

对于将被替换出去的页面，假如该页调入主存后没有被修改，就不必进行处理，否则就把该页重新写入外存，以保证外存中数据的正确性。为此，在页表的每一行应设置一修改位



![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414205457.png)



![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220414205356.png)



## 存储管理部件

`MMU`是负责虚实地址转换的核心部件

功能：

1. 完成虚实地址转换，维护 `TLB` 控制机制，负责存储保护
2. 发起中断，维护 `TLB` 失效后的再填充机制

工作流程：

CPU发出发出访存的虚拟地址后，MMU访问主存页表，获得映射关系

若主存命中，则虚实转换，产生物理地址；若主存缺页，由操作系统进行调页操作



## IA-32 架构下的内存模型

1. 平坦模式

   在这种模式下，所有的段基址都是 0，相当于没有使用分段模式

2. 分段内存模型

    内存的线性地址由段选择寄存器 `CS DS ES SS`所指向的段描述符所提供的段基址 + 偏移量计算出来，从而将不同的数据隔离开

3. 实地址的内存模型

   目的是兼容 `8086` 处理器，`CS DS` 本身就包含段的基地址，每个段的大小只有 `64KB`，地址空间只有 `1 MB`

注意，在 `平坦模式` 和 `分段模式` 下，段中的地址还可以进一步进行分页规划，而对于实地址模式意义不大

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220418192047.png)



### IA-32 下基本的运作模式

1. 保护模式

   这是最常见的模式，这是一个受保护并且支持多任务的环境，在这个模式下，能够对内存以及外围的一些设备提供硬件级别的保护设置，如分段分页机制，大部分的 OS 都运行在这个环境下

   在这种模式下，`CS DS` 被称为 `segement selector`，用于从段描述表 (`GDT LDT`) 中选择描述符来得到基地址

2. 实地址模式

   为了兼容 `8086` 系列，在通上电的时候就会处于这个模式

   寻址空间只有 `1MB`，`CS DS` 等被称为是 `segement register`，这时段的基地址只是其左移4位之后得到的

3. 系统管理模式(SMM)

   提供和平台相关的管理环境，环境由 `UEFI/BIOS` 提供，有自己独立的空间，处理器或者是可编程中断控制器在接收到 `SMI(串行接口)`上的中断时候就会进入
   
4. `IA-32e` 模式
   
   - 兼容模式
   - 64 位模式，让应用程序能够访问 64 位的地址，扩展了通用寄存器的宽度和数量



 不同的允许模式和内存模型的对应如下：

1.  保护模式：

   三种内存模型都能用，实地址内存模型通常是在 `virtual-8086` 模式下

   当允许多任务时，每种任务都可以采用不同的内存模型

2. 实地址模式，只能采用实地址内存模型

3. 系统管理模式

    该模式会切换到SMRAM中，所采用的内存模型类似于实地址模式内存模型 

4. 兼容模式

   和 32位保护模式一样

5. 64 位模式

   分段机制不常用，通常采用平坦内存模型，所有的端基地址都为0，段的上限为最大值



## 总结

为了解决编程中主存容积受限和多程序使用的地址重叠的问题，引入了虚拟存储器

为了解决地址冲突，引入了不同的虚拟地址的映射方式，为了加快映射的过程，引入了功能与 cache 类似的 `TLB` 来加速

TLB Cache 主存这三者互相协作提高访存效率

