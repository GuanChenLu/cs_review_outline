# 浮点运算规则



## 浮点加减运算

> 想象两个使用科学计数法表示的数做加减运算，首先需要将阶数化成相同，然后只要对 `尾数` 进行加减就能得到结果，在变换阶数的同时，尾数也要变换，从而还需要考虑精度和溢出

完成浮点加减运算的操作过程大体分为四步 ：

1. `0` 操作数的检查
2. 比较`阶码` 大小并且完成`对阶`
3. 尾数进行加减运算
4. **尾数规格化**并且进行舍入处理

先给一张 `基本流程图`

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322223648.png" style="zoom:67%;" />

其中：

1. `0` 操作数检查就是遇到 `0` 直接输出另外一个数

2. 使两数 `阶码相同` 的操作称为 `对阶`，如果两个浮点数阶码不同，我们需要`使小阶数的尾数的小数点向右移动，增加小阶数使之于较大的阶数最终相同`**小阶向大阶看齐**)

3. 尾数进行加减运算的规则就是**定点补码加减运算**

4. 最后进行**规格化**，规格化就是通过移动小数点（加减阶数）将尾数相加减的结果`x`表示为 `1/2 <= |x| < 1`的范围

   <img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322225212.png" style="zoom:50%;" />

   <img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322225350.png" style="zoom:50%;" />

5. 在舍入操作之前，为了使舍入操作有意义，需要检查是否上/下溢出

   在这里的溢出可能会有 `尾数溢出` 和 `阶码溢出`，但是一般考虑的是 `阶码溢出`，因为（如上图所示）我们总是可以通过尾数左右移来保证尾数是合法的，在此期间会产生 `阶码溢出`

   对于溢出的数据，如果是`下溢`，通常当作是`机器0`来处理，如果是上溢常常会触发中断处理

6. 最后进行舍入操作

   结果产生偏差的原因是在**对阶(这里也可以看出是小向大看齐)**或**向右规格化**的过程中，位数要向右移动，被右移尾数的地位部分要舍去，从而造成一定的误差

   通常采用下面的两种舍入方式

   1. `0舍1入`：就像是 `四舍五入`，如果右移时被舍去的最高位是`0`则舍去，`1` 则将尾数的末位 `+1`
   2. `恒置1`：无脑 `+1`

   还有两种 `IEEE754` 中的方法



这边直接上题

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322231141.png" style="zoom: 50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322231222.png" style="zoom:50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322231414.png" style="zoom:50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220322231433.png" style="zoom:50%;" />





## 浮点乘除运算

乘除运算更加简单，甚至不用`对阶`

可以大致分为以下的五步操作

1. `0` 操作数检查
2. 阶码加减操作
3. 尾数乘除操作
4. 结果规格化
5. 舍入处理

其中，阶码加减操作需要关注一下，如果阶码是补码，就直接使用 `补码的加减操作`，如果是用**移位码**表示，则有一下的运算操作

![](https://gitee.com/chenlu-guan/t-image/raw/master/20220322232137.png)

位数部分的乘除运算直接由定点乘法/除法器来完成，只需要知道结果就行 :accept:

- [x] 乘法例题

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323160647.png" style="zoom:50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323160825.png" style="zoom:50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323160851.png" style="zoom:50%;" />

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323160921.png" style="zoom:50%;" />



## 浮点运算流水线方式



拿生活中的洗衣服的例子来说，笼统的可以将这种操作分成四步

1. 清洗
2. 烘干
3. 晾晒
4. 存放

如果采用串行的方式来处理，即在执行完这四部操作时候再重复执行这四部操作，那么如果有四堆衣服，完成四步骤操作的时间为 `4T`，总时间就是 `4 * 4T = 16T`

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323161536.png" style="zoom:67%;" />

如果采用流水线的方式进行操作，只需要花费 `7T` 就能完成

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323161657.png" style="zoom:67%;" />



我们将任务分割成 `K` 级流水线，假设总共需要完成 `n` 个任务，那么可以得出使用流水线的方式完成所有的任务需要的时间为 `k + (n - 1)`个周期，而使用非流水线串行的方式则需要 `k * n` 个周期

我们将上述两式相除，即可得到加速比

```shell
C   = t(非流水) / t(流水)
	= n * k / k + (n - 1)
	= k (n >> k)
```



我们在上面讨论的浮点运算就可以采用流水线的方式进行实现来提高处理效率

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323162449.png" style="zoom:67%;" />





## 流水线拓展：为什么有序数组求和更快

> 以下的内容参考自  [今天去洗车，我居然发现 CPU 的秘密… (qq.com)](https://mp.weixin.qq.com/s/arAt6tDYq-mM9k0BnSa-Jg) 

笔者使用 `C++` 写了一个数组求和的函数，发现对数组进行排序之后得到结果的速度比无序数组求和的速度快很多

```c++
#include <algorithm>
#include <ctime>
#include <iostream>

int main()
{
    // Generate data
    const unsigned arraySize = 32768;
    int data[arraySize];

    for (unsigned c = 0; c < arraySize; ++c)
        data[c] = std::rand() % 256;

    // !!! With this, the next loop runs faster.
    std::sort(data, data + arraySize);

    // Test
    clock_t start = clock();
    long long sum = 0;
    for (unsigned i = 0; i < 100000; ++i)
    {
        for (unsigned c = 0; c < arraySize; ++c)
        {   // Primary loop
            if (data[c] >= 128)
                sum += data[c];
        }
    }

    double elapsedTime = static_cast<double>(clock()-start) / CLOCKS_PER_SEC;

    std::cout << elapsedTime << '\n';
    std::cout << "sum = " << sum << '\n';
}
```



### CPU采用流水线的方式执行指令

上面我们提到了流水线操作的原理，其实在 `CPU` 内部执行指令(代码)时也是这样的

首先我们需要明确：各种外部设备通过 `地址总线、数据总线、控制总线`和 `CPU` 打交道



程序经过编译器处理成机器码来执行，程序会被翻译成一条条的指令 

CPU 执行指令的过程大概可以分为以下的五部

1. **取指令 IF**
   取指令（Instruction Fetch，IF）阶段是将一条指令从**主存中**取到指令的过程

2. **指令译码 ID**
   取出指令后，计算机立即进入指令译码（Instruction Decode，ID）阶段。
   在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法

3. **指令执行 EX**
   在取指令和指令译码阶段之后，接着进入执行指令（Execute，EX）阶段。
   此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能

   为此，CPU 的不同部分被连接起来，以执行所需的操作

4. **访存取数阶段 MEM**
   根据指令需要，有可能要访问主存读取操作数，这样就进入了访存取数（Memory，MEM）阶段

   此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算

5. **结果回写 WB**
   作为最后一个阶段，结果写回（Writeback，WB）阶段把执行指令阶段的运行结果数据写回到某种存储形式



为了提高效率，`CPU` 采用流水线的方式执行这五步

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323163722.png" style="zoom:67%;" />

流水线的级数也被称为深度，当前 intel 的酷睿 i7 采用了 16 级深度的流水线，在一定范围内提高流水线深度可以提高 CPU 的吞吐量，但是也为硬件设计带来很大的挑战，甚至降低吞吐量 



### `CPU` 流水线冒险

通过流水线设计来提升 CPU 的吞吐率，是一把双刃剑，在提高吞吐量的同时我们也在冒险 

提到流水线设计需要解决的三大冒险：结构冒险（Structural Hazard）、数据冒险（Data Hazard）以及控制冒险（Control Hazard） 



#### 结构冒险

结构冒险本质上是一种硬件冲突

举个例子，如果在内存中只有一个地址译码器，那么就不能同时执行 `IF` 和 `MEM`

换句话说，就像你家只有一个锅，你不能指望着边炸鱼边炒菜



对于上述的 `IF` 和 `MEM` 的冲突，一种解决方案就是将存取指令的内存和存放数据的内存分开来，让他们拥有各自的地址译码器

这种将`指令`和`数据` 分开存放的结构就是 `哈佛架构`，另一种就是 ` 冯诺依曼/普林斯顿架构 `

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323170653.png" style="zoom:50%;" />



这两种结构有各自优缺点，现代 CPU 借鉴了两种架构，采用一种混合结构，并且引入高速缓存，来降低 CPU 和内存的速度不匹配问题 

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323170749.png" style="zoom:67%;" />

这种混合结构属于属于硬件层面的优化 





#### 数据冒险

数据冒险是指令之间存在数据依赖关系，就像下面这段代码：

```c
int a = 10;
int b = a + 10;//语句2
int c = b + a;//语句3
```

这种情况下语句3的执行依赖于语句2，在 `CPU` 中执行的指令之间就会存在依赖关系



比如说指令 3-3 需要等待指令 2-2 完成 WB 阶段才可以进行 EX 阶段，如果不等待，得到的结果就是错误的 

一种简单的操作就是在等待依赖的数据计算完成之前什么事情都不做，这种通过流水线停顿来解决数据冒险的方式称为 `流水线冒泡 (Pipeline Bubble)`

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323171525.png" style="zoom:50%;" />



流水线冒泡虽然简单，但是效率却下降了 , 我们完全可以在第一条指令的结果数据直接传输给到下一条指令的 ALU，这样的话，下一条指令就不需要去取上一条指令 `WB` 的结果了

这种将结果直接传输的技术称为`操作数前推/转发 Operand Forwarding`，它可以和流水线冒泡 NOP 一起使用，因为单纯的操作数前推也无法完全避免使用 NOP 

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323171758.png" style="zoom:67%;" />



>  `小结`：操作数前推，就是通过在硬件层面制造一条旁路，让一条指令的计算结果，可以直接传输给下一条指令，而不再需要指令 1 写回寄存器，指令 2 再读取寄存器，这样多此一举的操作 



#### 控制冒险



在流水线中，多个指令是并行执行的，在指令 1 执行的时候，后续的指令 2 和指令 3 可能已经完成了 IF 和 ID 两个阶段等待被执行，此时如果指令 1 一下子跳到了其他地方，那么指令 2 和指令 3 的 IF 和 ID 就是无用功了 

 遇到这种指令转移情况，处理器需要先**排空**指令 2 和指令 3 对应的流水线，然后**跳转**到指令 1 的新的目标位置**进入新的流水线**，这部分称为 **转移开销**，这也是产生性能损失的重要原因 



转移开销的构成

1. 转移条件判定
2. 生成目标地址
3. 排空其他的流水线



>  转移指令本身和流水线的模式是冲突的，因为转移指令会改变指令的流向， 而流水线则希望能够依次地取回指令，将流水线填满的，但是转移指令在实际程序中非常普遍，这也是 CPU 流水线必须要面对的问题 



转移指令分为 `无条件跳转` 和 `条件跳转`

无条件转移是确定发生的，并且跳转地址在取指阶段就能得到，我们在 CPU 里面设计对应的旁路电路，把计算结果更早地反馈到流水线中，这种属于硬件方案称为缩短分支延迟 



 但是，**对于条件转移我们在 IF 阶段并不能获得跳转位置，只能等 EX 阶段才知道，这就引出了分支预测** 



##### 分支预测

换句话就是，流水线上的上一个工作还没有完成，但是下个指令是依赖于这个结果的

**为了效率，流水线不能停顿住，必须要做个选择，向左走还是 向右走，选择出下一条要执行的指令，哪怕错了，也比等待好，万一猜对了呢** 



 分支预测有：**静态分支预测和动态分支预测** 



静态分支预测就是每次都选择一个结果，有 `50%` 的可能，简单但是不够高效



动态分支预测会根据之前的选择情况和准确率推断当前的情况，判断出是`顺序分支`还是 `跳转分支`

- 预测成功时，尽快找到分支目标指令地址，避免控制相关造成流水线停顿
- 预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令



具体一点，考虑到之前的选择情况以及对后面产生的可能影响的模型可以使用`状态机`来实现

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220323173013.png" style="zoom:67%;" />



标记分支状态以及分支历史的一段内存被称为 `BTB`，这段内存只存储了`分支指令地址`、`预测的目标`地址以及`预测的位 `



经过前面的分析可以看到：

动态分支预测器具有一定的容错性，并且波动性较小，只有连续两次预测失败才会转变选择结果，整体正确率提升明显



从一些文章的数据显示，大部分情况下 2bit 预测器准确率可以达到 95% 以上 



### 回归问题

可以看到，数组中的元素在排序之前有以下的特点

- 数组元素是完全随机的，本次结果和上次结果是独立分布的
- 大量循环结构和条件判断的存在

**随机+循环+条件就彻底命中了 CPU 流水线的软肋** 



排序之前的分支预测

```c
data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, ...
branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T  ...

       = TTNTTTTNTNNTTT ...   (completely random - impossible to predict)
```

分支预测失败就意味着流水线排空，废弃已经进行 IF 和 ID 的指令，然后再选择正确的指令，整个过程在目前 CPU 来说要浪费 10-20 个时钟周期，这样耗时就上来了 



排序之后的分支预测

```c
T = branch taken
N = branch not taken

data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...

       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)
```

数组排序后，动态分支预测**会结合之前的结果做出判断**，准确率非常高，未排序时完全随机和静态分支预测差不多了，因此准确率一般 





- [x] 流水线的原理，效率公式

- [x] 为什么有序数组求和更快



<br/><br/>

完

<br/><br/><br/><br/>



---

计算机组成原理小计持续更新，欢迎关注 :smile:





