## CC 小计 0x01 —— 计算机中的数字的表示方法篇

> 前言：
>
> 在计算机中，所有的数据都是二进制形式的，基于此，需要有一种规则将在日常中使用的十进制数（包括精确的形式）转化成为计算机能够表示的制度，这就延伸出了在计算机中数据的表示方法。本文将主要通过讲述 `32位浮点类型` 在计算机中的表示方法来切入分析计算机中数据的表示方法



### 先来制造疑惑

先来看下面这样一段代码

```c
#include <stdio.h>

int main() {
    int num = 0x41360000;
    int *p_num = &num;
    printf(" num = %X in Hex\n", *p_num);
    printf(" num = %d in Dec\n", *p_num);

    float f_num = *(float *)p_num;
    printf(" num = %f in Dec presented in TYPE FLOAT\n", f_num);
}
```



你可能会说，这没有什么大不了的嘛，`float`类型不就是在呈现的时候小数点之后多几位而已嘛，可是结果却大相径庭

我们编译执行后结果如下



![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228191321.png)



等等，这个 `11.375` 是什么？

稍微对指针机制和 `32位浮点数类型`有了解的人也许会对内存中拿到情况了解一点，我之前对此的理解也是这样的：`int`型和 `32位浮点型`所占的内存大小都是 `4字节`，这里所作的时就是先定义了一个占满 `32位` 的 `int` 型变量，然后使用指针作为中间的媒介将这个值交给一个 `float` 型变量，换句话说就是把这个内存区域（注意不是值）当作是 `float` 类型所占的空间去处理，然后输出代表这块区域的 `float` 类型的变量的值



你可能已经猜出了一点，既然结果出现了小数部分，那么这个小数部分是怎么样由二进制数表示出来的呢？换句话说，在 `float` 中是以怎么样的规则来定义一个数的呢，带着这些疑问，我们从数据在计算机中拿到表示开始，一探究竟



### 数据的分类

我们在电脑上呈现出来的内容中，数字只占很小一部分，但是，硬件是只和数字打交道的，所以说，我们看到的只是数字的一种表现方式，按照表现方式来分类，我们大致可以把数字分为两类

- 数值数据
- 非数值数据

在数值数据中，为了表示更大范围的数据以适用于人类，某些特定的数据将被当作是符号来处理（比如说正负号），据此可以将数据分为无符号数（正整数）和有符号数

总体上的分类如下

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220228193215.png" style="zoom:67%;" />



我们现在对有符号数进行研究



### 定点数

所谓的定点格式，就是约定机器中所有的数据的小数点位置是固定不变的，由于约定在固定的位置，小数点就不用使用 '.' 来表示，从原理上来说，小数点标记在哪一位都可以，但是通常将数据表示成纯小数（预定小数点在开头）和纯整数（约定小数点在末尾）

假设使用一个 `n + 1` 位的字来表示一个定点数，将最左边（约定）的`xn`表示为正负号，这样，对于任意定点数 `x = xnxn-1xn-2 ... x0`，在的定点机中表示为如下形式

![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228194054.png)

显然，如果 `x` 表示的是纯小数，那么小数点在 `Xn ~ Xn-1` 之间，当 `Xn-1 ~ X0` 各位均为 `0` 时，绝对值最小为 `0`，当各位均为 `1` 时，绝对值最大为`1 - 2^-n` 

反之，如果 `x` 表示的是纯整数，那么小数点位于最低位 `X0` 的右边，此时绝对值表示范围为 `[0, 2^n - 1]`



### 浮点数

在对上述的定点数做分析的时候我们发现，其所容许的数据范围较小，如果引入非常大的数或者是非常小的数便无法表示

如果将这些极端的数据（以较大的数据为例）缩小好几倍以达到我们能够表示的范围，那么就可以使用我们能够表示的数来表示，就好比是科学计数法一样，我们有一个十以内范围的数和一个使用 `10 的几次方` 来表示的比例因子，同样的，在计算机中任意一个二进制数也能够写成

`N = 2^e * M`

的形式

为了统一名称，我们将上述公式中的 `2` 成为基数，`e` 成为阶数，`M` 称为尾数

所以，一个能够用来表示比较大数据范围的数字应该由 `阶数` 和 `尾数` 这两部分组成，如果规定了存储这两个元素的内存长度为 `32位`，那么如果将这段内存看作是某种类型的数据的话，这就是 `32位单精度浮点数`，就是我们在 `C` 语言中所说的 `float` 类型



根据 `IEEE` 标准，这个 `32位`的存储空间的内存分配如下

![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228200541.png)

这里面的移位和小数部分下面会说，首先应该记住 `1 + 8 + 23` 的布局

`64位双精度浮点型`数据的表示就是 `1 + 11 + 52`



### 一切与逻辑无关的都是规定

#### 将最后的23位视作纯小数

我们首先来看最右边（约定）的`23`位

对于二进制数 `1011.1101`，该采用那种表示？

![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228201226.png)



于是有以下规定：

在计算机内，浮点数的尾数是纯小数，对非`0`值的浮点数，要求尾数的绝对值必须 ≧ 1/2，即尾数域的最高有效位应为1,称满足这种表示要求的浮点数为规格化表示

​																			`0.1000101010` 



对于不满足这一格式的尾数，可以通过 `尾数移位`(就是把尾数向前移到 `1` 占尾数最高位)和 `修改阶码`（将阶数变小）来表示，这里需要一点左右移的知识

 

既然非 0 值浮点数的尾数数值最高位必定为 `1`， 则在保存浮点数到内存前，通过尾数左移，强行把该位去掉, 用同样多的尾数位就能多存一位二进制数， 有利于提高数据表示精度，称这种处理方案使用了隐藏位技术 

这样，在取回浮点数到计算器中进行运算的时候，就要将该隐藏位复原

![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228201706.png)



是不是对开始的问题有思路了？别急，对于阶码的表示还有一种规定 :cry:



#### 将阶码 - 127 视作真正的阶数

如果我们采用一般的符号位表示正负的方法来表示向阶码那样的 `8位` 数字的话，所能表示的范围是 `-128 ~ 127`

如果将 `8位数据` 当作是无符整数，采取 `阶码-127`的策略来算的话，我们能够表示的**真实的阶数**的范围是 `-127 - 128`

可以看出，这样的表示实际上是和有符号数所能表示的范围差不多的，但是，介于计算机需要表示一些特殊的数，一些特殊的 `阶数` 和 `尾数` 需要被枚举出来当作是特例，咱这里就不展开说这些特里了，在下表中列出，可以将其中的 `正负非规格化数`当作是无限接近于 `0` 的数来处理



![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228202218.png)



所以，真实的阶数的范围是 `-126 ~ 127`



### 转换公式

相比你已经推出转换的公式了吧

如果将符号位看作是 `S`，阶码看作是 `E`，尾数看作是 `M`的话，`32位单精度浮点型数`转换成十进制数字的公式如下

```matlab
X(Decimal) = (-1)^S * (1.M)b * 2^(E - 127)
```

其中 `b` 表示的是二进制



### 回到问题

相信你已经对开始的问题有解答了，下面我再来解释一下

我们首先使用 `0x41360000`占了 `32` 字节的长度，然后常识将这些数据表示为一个 `float`类型的变量的内存中的布局

说明白点，就是将 `0x41360000` 按照上面的规定转化成 `float` 类型的数

下面是转换的过程

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/490d887ee5a0830a8999a75f9b72446.jpg" style="zoom:60%;" />



哈哈，这不就出来了吗   :kissing_smiling_eyes: :kissing_smiling_eyes:



如果做点“蠢事”，（可能会有人想我一样被自己绕进去了），将这个 `float` 类型的数字转成 `16进制` 来表示，结果会是什么样的呢

```c
#include <stdio.h>

int main() {
    int num = 0x41360000;
    int *p_num = &num;
    printf(" num = %X in Hex\n", *p_num);
    printf(" num = %d in Dec\n", *p_num);

    float f_num = *(float *)p_num;
    float *p_f_num = &f_num;
    printf(" num = %f in Dec presented in TYPE FLOAT\n", f_num);
    printf(" num = %x in Hex presented in TYPE FLOAT\n", *(int*)p_f_num);
}
```



![](https://gitee.com/chenlu-guan/t-image/raw/master/20220228210628.png)



哈哈哈，这肯定是原来的数字呀 :joy: :joy:

这也再次验证了前面说的一句话，在计算机里面存储的只是最普通的数据，我们能够看到如此多样化的类型只是数据按照不同的规则表现出来的差异，所以说，这篇文章实际上是在和你讲**述数据的表示规则，帮助你避免一些不必要的麻烦而已啦 ​**:triangular_flag_on_post:



### 总结

本文围绕计算机表示数据和入门日常中表示数据的习惯之间的差异展开，将计算机中的数据按照表示方法不同进行了简单分类，并且对定点数和浮点数的表示规则进行说明，最后回到开始的问题，着重对浮点数的表示以及计算过程做了说明，窥探了数据在计算机中的存储



希望你有所收获



完





