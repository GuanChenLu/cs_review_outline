# 指令系统



## 计算机系统的结构层次

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428204026.png)



指令就是计算机执行某种操作的命令

归根结底，计算机中的程序是由一系列的指令组成的



基于指令的应用规模，我们可以将指令分为以下三种

1. 微指令

   微程序级别的指令，属于硬件的层面

2. 机器指令

   介于微指令和宏指令之间，简称指令，每条指令可以完成一个单独的逻辑或算数运算

3. 宏指令

   由若干条机器指令组成的软件层面的指令



指令系统是计算机中所有指令的集合，和低级语言(二进制、汇编)关系较大



指令系统通常需要满足以下的四个要求

1. 完备性

   提供足够多的指令给汇编语言使用

2. 有效性

   利用指令系统所编写的程序能够高效地运行

3. 规整性

   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428204903.png)

4. 兼容性

   新机器上能够跑原来运行在老机器上的程序



## 指令格式

> 汇编语言复习



### 操作码

就是可以在操作码的位数限定的范围中任意地定义，可以是定长的，也可以是变长的(扩展操作码)

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428210650.png)

操作多地址的操作码不能够被操作少地址的操作码覆盖，所以需要从多操作数读的操作码开始考虑，将它当作前缀

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428210838.png)





![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428205642.png)

指令格式就是指令字使用二进制码表示的结构形式



### 地址码

地址码表示操作数或者是操作数的地址，可以用来存放运算结果的地址

烦死了，怎么这么多中文的概念，简直是有病 :sob:

还 essential 的是，这个操作数可以是寄存器的编号，主存地址，I/O 地址



按照操作数的条数，可以将指令分为哪几种啦 :cat:

其中，二地址指令可以根据源操作数和目的操作数的类型分为三类

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428210350.png)



### 指令字长度

就是一条指令所占的二进制的位数

机器字长是 CPU 一次能够处理的二进制位数

按照指令所占的位数和机器字长的遍历就可以将指令分为

1. 等长指令字结构

   一个指令系统中的所有的指令的长度是相等的

   优点是，结构简单，且指令的长度是不变的

2. 变长指令字结构

   指令的长度随功能而变化

   结构灵活，能够充分地利用指令长度，但是指令的译码和控制较为复杂

3. 多字长指令

   可以用来提供足够的地址位来解决访问地址的寻址问题

   但是需要多次访问存储来取出，降低了 CPU 的计算速度，占用了额外的存储空间



### 指令注记符

就是例如 `ADD SUB MOV JMP `等等的字符化的指令格式

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428212248.png)





## 指令格式举例

### 8位微型计算机的指令格式

了解一下

纯粹的格式

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428212438.png)



### MIPS 指令

要不是要考谁来学

> MIPS 是一种 `RISC(Reduced Instruction Set Compputer)`使用的指令格式，指令格式简单数量少，只有 32 个寄存器

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428212809.png)

所有的算术指令，数据必须被放在通用寄存器中，称为 R 型指令

```shell
op(6 bit) rs(5 bit) rt(5 bit) rd(5 bit) shamt(5 bit) funct(6 bit)
 ^        ^         ^         ^           ^            ^
 |        |         |         |           |            |
操作码  源操作数1 源操作数2  目的数寄存器   位移值   指定 R 类型指令的操作
 
```



### ARM指令格式

ARM 是字长为 32 位的，属于 `RISCV`，指令是定长的 32 位

```shell
cond	F		I	opcode		S	Rn	Rd	operand2
 ^      ^    	 ^     ^      	 ^   ^    ^      ^
 |      |    	 |     |      	 |   |    |      |
 条件 指令类型   立即数 操作码  设置状态 源  目的  第二个源操作数
 4      2         1     4        1    4    4     12
 
```



### 奔腾指令结构

非固定长度

从 1 ~ 12 字节，还可以带前缀

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428215154.png)



补充：变址寄存器(`EDI、ESI` 等)存放存储单元在段内的偏移量，实现多种**存储器操作数**的寻址方式



### 对 MIPS 指令的解析举例

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220428221814.png)

![1651155534535](C:%5CUsers%5Cgcl%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1651155534535.png)





## 操作数类型

一般的数据类型

- 地址数据
- 数值数据
- 字符数据(格式化成字符)
- 逻辑数据(“裸露”的二进制位组成)



## 指令和数据的寻址方式

指令的寻址方式用于形成指令在内存中的地址

操作数的寻址方式用于形成操作数在内存中的地址



### 指令的寻址方式

按照 `PC` 变化的规律，指令的寻址方式分为顺序寻址和条约寻址

<img src="https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220509172259.png" style="zoom:80%;" />



跳跃寻址方式中，下条指令的地址吗不是由 `PC` 给出而是由本条指令给出

同时，`PC` 的值也必须改变

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220509172510.png)



### 操作数的寻址方式

给出操作数的形式地址，还有变换的规则——寻址方式特征位，可以将形式地址映射成有效地址

1. 隐含寻址，不给出第二个操作数的地址 (`DIV	BL` == ` AX  / BL`)

2. 立即寻址，指令字段直接给出操作数本身

   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510090434.png)

3. 直接寻址，直接给出操作数在内存中的地址，`D = (A)`

   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510090536.png)
   
4. 间接寻址，给出的形式地址是操作数地址的指示，通常通过一个标志位和直接寻址做区分
   
   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510090755.png)
   
5. 寄存器直接 / 间接寻址，操作数 / 操作数的地址 放在寄存器中
   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510090913.png)
   
6. 偏移寻址

   - 相对寻址，偏移当前指令地址的相对寻址， `EA = A + (PC)`，便于程序在内存中成块移动

       ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510091305.png)

   - 基址寻址，将 `CPU` 中的基址寄存器加上给出的偏移地址，`EA = (Rb) + A`

       机制寄存器的位数可以大于形式地址，可以扩展操作数的寻址范围

       ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510091411.png)

   - 变址寻址，将变址寄存器和偏移量相加，`EA = (Rx) + A`

       形式地址 `A` 中给出基准地址，偏移量由 `Rx` 给出，可以实现重复的操作

       ![1652145447641](C:%5CUsers%5Cgcl%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1652145447641.png)

   

7. 段寻址，就是基址是 `CPU` 中的段寄存器

   举例，可以将 `16`位的段寄存器左移四位然后和偏移量相加，就可以得出地址
   
   在这种模式下，可以将 `1MB` 的内存空间划分成最大长度为 `64KB` 的若干个段
   
   ![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510092215.png)
   
8. 堆栈寻址，通过 `PUSH` 和 `POP` 来从栈顶存取数据，需要有一个隐式或者是显示的堆栈寄存器
   



### 寻址方式总结

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510093222.png)



`     Pentium  ` 处理器在实模式下为段寻址方式，段寄存器中的内容左移四位加上偏移地址得到 20 位的物理地址

在保护模式下，`32` 位的段基地址加上段内偏移得到 `32` 位的线性地址，由 `MMU` 转换为物理地址



`Power PC`的寻址方式

![](https://pic22go.oss-cn-beijing.aliyuncs.com/md/20220510093341.png)



## 典型指令

鼠鼠都知道

![1652146716819](C:%5CUsers%5Cgcl%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1652146716819.png)

### CISC

复杂指令集

- 指令的数量多，格式多，寻址方式多
- 大多数指令需要多个 `CPU` 周期才能完成
- 各种指令都可以访问存储器
- 采用微程序控制
- 有专有寄存器
- 难以编译优化生成高效的代码



### RISC

- 指令的数量少，精简，寻址方式少，指令的格式少， 长度固定
- 只有存取数据需要访问存储器
- 采用大量的寄存器，高速缓冲寄存器，优化存储技术，减少访存的事件
- 采用阵列逻辑实现的组合电路控制
- 以流水的方式控制，在一个时钟周期内执行完成
- 采用优化编译技术，保证流水畅通，对寄存器分配进行优化



