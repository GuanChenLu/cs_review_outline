# CC小计 —— 定点乘法运算

> 上节我们主要讲了补码数据的运算，这节我们聊一聊定点数的乘法运算



## 自然乘法运算和一位串行乘法规则

在定点计算机中，两个原码表示的数相乘的运算规则是：乘积的符号位由两数的符号位按异或运算得到，乘积的数值部分则是两个正数的乘积之和

关于符号的部分前面讲过便不再赘述，而关于数值运算的方法与普通十进制小数乘法类似，并且使用二进制来表达更为简单

下面展示的是求 `1101` 和 `1011` 的乘积的运算方法

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/9b29260018081599d3b07cd308a85f0.jpg" style="zoom:67%;" />

如果使用定点小数的话，亦是如此，且不要忘记要在前面加上两 `0` :baby:



在早期的计算机中，为了简化硬件结构，采用 `加法 - 移位` 的方式来实现乘法，实现上述乘法的过程如下所示



<img src="https://gitee.com/chenlu-guan/t-image/raw/master/1cda5ad1ab2d055fb7a62d4dedb43d3.jpg" style="zoom:67%;" />



不难看出，这种方法对采用的是 `部分积右移`的策略，根据最低位 `PR0` 来判定

- 如果 `PR0` 为 `1`，则将左边四位加上被乘数，接着向右移动一位(剔除原来的 `PR0`)
- 如果 `PR0` 为 `0`，则直接向右移动一位(剔除原来的 `PR0`)



这种方法不需要太多器件，但是效率较低





## 列阵乘法器与其计算时间

可以将一个二进制数按照 `a = ∑ ai 2^i` 来表示

两个位数分别为 `m` 和 `n` 的二进制数相乘产生 `m + n` 位乘积 `P = pm+n-1 * ... * p1 * p0`

实现这个乘法过程所需的操作和入门习惯方法类似



<img src="https://gitee.com/chenlu-guan/t-image/raw/master/24a1424ae82f026ed612ba5a14001d6.jpg" style="zoom:50%;" />



上述说明了在 `m * n` 列阵乘法中 `加法 - 移位`操作的被加数矩阵

每一个 `ai*bj` 都可以叫做一个被加数，这里所有的被加数都可以使用`与门`并行地产生，显然高速并行乘法器的速度受限于每列包含的加法时间

我们以 `5 * 5` 列阵乘法器为例来说明



<img src="https://gitee.com/chenlu-guan/t-image/raw/master/2c5eee996f477e7f2d25b50332e2920.jpg" style="zoom:50%;" />

其中的加法单元 `FA` 是上一节中我们所讲的 `一位全加器`、`FA` 斜线反向表示进位输出、竖线方向表示和输出，所有被加数项的排列和前面所描述的被加数矩阵相同

图中最底下一行使用 `虚线` 框起来，这部分构成了一个 `行波进位加法器`，其求和延迟为 `(n - 1) * 2T + 3T(异或门)`



假如假设延迟时间和前面一节一致，即全加器进位延迟时间为 `2T`，使用2级 `与或` 逻辑来实现 `FA` 的话

总时间就是

```shell
tm = T + (n - 1) * 6T + (n - 1) * 2T + 3T
```

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/f1f12db9f10991e7b3d842f7bbdf7f2.jpg" style="zoom:50%;" />

逻辑示意图可以画成下面这样

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/20220309204642.png" style="zoom:50%;" />



## 带符号的列阵乘法器

对于带符号的列阵乘法器的结构来说，其对于数字的表示方法有所不同

在介绍带符号的列阵乘法器之前，我们先来介绍一下常用的 `求补电路`

求补时，采用 `按位扫描`技术来执行求补操作，具体的算法如下

1. 从二进制数的最右端开始，从右到左扫描到找出第一个 `1` 的位置，记为 `ai`
2. `ai`自己和它右边的位保持不变，而以左的每一个输入位都取反

所以，我们需要设计一个前一位对后一位有影响的电路



<img src="https://gitee.com/chenlu-guan/t-image/raw/master/405fe1c297c84df91884f992751920b.jpg" style="zoom:50%;" />



可以看到，`E` 代表的是符号位，当代表是正数时(E = 0) 时结果保持不变

当 `E = 1` 时，当前符号位上如果为 `1`，则之后的 `cn` 就为 `1` ，后面的输入与 `1` 进行异或，达到取反的效果



每个扫描需要 `2T` 延迟，还有 `与门` 和 `异或` 的 `5T`

所需的总延迟时间为 `tnc = n * 2T + 5T`



下面我们来看看带符号的列阵乘法器的实现

通常，把包含这些求补级的乘法器又称为 `符号求补阵列乘法器`

<img src="https://gitee.com/chenlu-guan/t-image/raw/master/e576bb95273ecd8a849f9e778a96fb9.jpg" style="zoom:67%;" />



需要说明的是，被除数 `A` 和乘数 `B` 输入的 `n` 位数是所谓的 `裸数据`（可以理解为包含符号，注意不是符号位的数），因此需要转化成 `n + 1` 位的补码形式后，然后在对于除符号位以外的部分进行乘法运算(绝对值乘法运算)

显然，结果的符号由第一遍求补码时的符号确定



> 当然，考试的时候可以选择直观的方式进行验证



<br/><br/>

完

<br/><br/><br/><br/>



---

计算机组成原理小计持续更新，欢迎关注 :smile:



